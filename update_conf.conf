input {
  stdin {type => "syslog"}
  file {
    type => "syslog"
    start_position => "beginning"
    # Wildcards work, here :)
    path => ["/Users/per.berglund/work/volkswagen/brumm/javaSrc/testFile.log"]
  }
}

filter {
  if [type] == "syslog" {
    mutate {
      remove_field => [ "tags" ]
    }
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{HOSTNAME:syslog_hostname} %{DATA:syslog_program} \[%{NONNEGINT:syslog_instanceid}\] %{GREEDYDATA:syslog_message}" }
      add_field => [ "instanceid", "%{syslog_instanceid}" ]
      add_field => [ "appid", "%{syslog_program}" ]
    }
    syslog_pri { }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
    if !("_grokparsefailure" in [tags]) {
      mutate {
        replace => [ "@source_host", "%{syslog_hostname}" ]
        replace => [ "message", "%{syslog_message}" ]
      }
    } 
 
    mutate {
      #remove_field => [ "syslog_hostname", "syslog_timestamp", "syslog_loglevel", "syslog_instanceid", "syslog_program", "syslog_message" ]
      remove_field => [ "syslog_hostname", "syslog_timestamp", "syslog_loglevel", "syslog_message" ]
    }
    kv { 
       prefix => "msg_" 
       field_split => " "
       trim => ","
    }

  }
}

output {
  if [msg_documentId] and [msg_documentStatus] {
    elasticsearch { 
      status => "%{msg_documentStatus}"
      action => upsert_status
      host => localhost
      document_id => "%{msg_documentId}"
      protocol => http
      index_type => "docs"
      index => "documents-in-progress"
      template => "/Users/per.berglund/work/volkswagen/logstash/documents-state-template.json"
      template_name => "documents-state-template"
      template_overwrite => true
    }
  }
  elasticsearch { 
    host => localhost
    protocol => http
  }
}